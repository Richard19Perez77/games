import React, { useState, useEffect } from 'react';
import { View, TouchableOpacity, Text, StyleSheet, Alert } from 'react-native';

const colors: string[] = ['red', 'blue', 'green', 'orange'];

const SimonGame: React.FC = () => {
  // Stores the sequence of colors generated by the game
  const [sequence, setSequence] = useState<string[]>([]);
  // Stores the sequence of user inputs
  const [userSequence, setUserSequence] = useState<string[]>([]);
  // Flag to indicate if it's the user's turn to respond
  const [isUserTurn, setIsUserTurn] = useState<boolean>(false);
  // Tracks the current level (length of the sequence)
  const [level, setLevel] = useState<number>(0);
  // Stores the color that is currently "active" (flashing)
  const [activeColor, setActiveColor] = useState<string | null>(null);

  useEffect(() => {
    startGame();
  }, []);

  // Resets the game and starts a new sequence
  const startGame = (): void => {
    setSequence([]);
    setUserSequence([]);
    setLevel(0);
    // Pass an empty array to ensure we start fresh
    addColorToSequence([]);
  };

  // Adds a random color to the sequence based on the given previous sequence
  const addColorToSequence = (prevSequence: string[] = sequence): void => {
    const randomColor: string = colors[Math.floor(Math.random() * colors.length)];
    const newSequence: string[] = [...prevSequence, randomColor];
    setSequence(newSequence);
    setLevel(newSequence.length);
    playSequence(newSequence);
  };

  // Plays back the sequence by flashing each color
  const playSequence = async (seq: string[]): Promise<void> => {
    setIsUserTurn(false);
    for (let i = 0; i < seq.length; i++) {
      await new Promise<void>((resolve) => {
        setTimeout(() => {
          setActiveColor(seq[i]);
          setTimeout(() => {
            setActiveColor(null);
            resolve();
          }, 500);
        }, 500);
      });
    }
    setIsUserTurn(true);
    setUserSequence([]);
  };

  // Handles the user pressing one of the color buttons
  const handleUserPress = (color: string): void => {
    if (!isUserTurn) return;
    const newUserSequence = [...userSequence, color];
    setUserSequence(newUserSequence);

    const currentIndex = newUserSequence.length - 1;
    if (newUserSequence[currentIndex] !== sequence[currentIndex]) {
      Alert.alert("Game Over", "You pressed the wrong button!", [
        { text: "Restart", onPress: () => startGame() },
      ]);
      return;
    }

    if (newUserSequence.length === sequence.length) {
      setTimeout(() => {
        addColorToSequence(sequence);
      }, 1000);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.levelText}>Level: {level}</Text>
      <View style={styles.board}>
        {colors.map((color) => (
          <TouchableOpacity
            key={color}
            style={[
              styles.button,
              { backgroundColor: color },
              activeColor === color && styles.activeButton,
            ]}
            onPress={() => handleUserPress(color)}
            activeOpacity={0.6}
          />
        ))}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  levelText: {
    fontSize: 24,
    marginBottom: 20,
  },
  board: {
    width: 300,
    height: 300,
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
  },
  // Each button is sized to allow a 2x2 grid with appropriate spacing
  button: {
    width: 130,
    height: 130,
    margin: 10,
    borderRadius: 10,
  },
  activeButton: {
    opacity: 0.25, // Visual effect when the button is "flashing"
  },
});

export default SimonGame;
